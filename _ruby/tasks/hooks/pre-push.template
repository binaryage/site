#!/bin/sh
#
# Pre-push hook for BinaryAge site submodules
#
# This hook prevents pushing to the 'web' branch when the 'shared' submodule
# has unpushed commits. This ensures shared changes are always pushed to GitHub
# before the website changes that depend on them.
#
# Installation:
#   rake hooks:install
#
# Bypass:
#   git push --no-verify
#

# ANSI color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Read stdin to get the list of refs being pushed
# Format: <local ref> <local sha> <remote ref> <remote sha>
while read local_ref local_sha remote_ref remote_sha; do
  # Extract branch name from ref (refs/heads/web -> web)
  branch_name="${local_ref#refs/heads/}"

  # Only check when pushing to 'web' branch (deployment branch)
  if [ "$branch_name" != "web" ]; then
    continue
  fi

  # Handle new branch case (remote_sha is all zeros)
  if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
    # New branch - compare against HEAD
    remote_sha="HEAD"
  fi

  # Check if 'shared' submodule pointer has changed
  shared_changed=$(git diff --name-only "$remote_sha..$local_sha" 2>/dev/null | grep '^shared$')

  if [ -n "$shared_changed" ]; then
    echo "${BLUE}ðŸ” Checking shared submodule...${NC}"

    # Extract the new submodule pointer commit SHA
    new_pointer=$(git diff "$remote_sha..$local_sha" -- shared | grep '^+Subproject commit' | sed 's/+Subproject commit //')
    new_pointer_short=$(echo "$new_pointer" | cut -c1-7)

    # Verify shared directory exists and is a git repository
    if [ ! -d "shared" ]; then
      echo "${RED}âŒ ERROR: shared/ directory not found${NC}"
      exit 1
    fi

    if [ ! -d "shared/.git" ] && [ ! -f "shared/.git" ]; then
      echo "${RED}âŒ ERROR: shared/ is not a git repository${NC}"
      exit 1
    fi

    # Change to shared directory
    cd shared || exit 1

    # Unset GIT_DIR and GIT_WORK_TREE so git commands use the shared repo
    unset GIT_DIR
    unset GIT_WORK_TREE

    # Fetch latest from origin/master to ensure we have up-to-date refs
    echo "${BLUE}ðŸ“¡ Fetching origin/master...${NC}"
    if ! git fetch origin master >/dev/null 2>&1; then
      echo "${RED}âŒ ERROR: Failed to fetch origin/master from shared submodule${NC}"
      echo "Cannot verify if shared commits are pushed."
      echo ""
      echo "Try these steps:"
      echo "  1. Check your network connection"
      echo "  2. Verify shared submodule remote: ${GREEN}cd shared && git remote -v${NC}"
      echo "  3. Manually fetch: ${GREEN}cd shared && git fetch origin${NC}"
      echo ""
      echo "Or bypass this check (not recommended):"
      echo "  ${YELLOW}git push --no-verify origin web${NC}"
      echo ""
      exit 1
    fi

    # Verify origin/master ref exists
    if ! git rev-parse origin/master >/dev/null 2>&1; then
      echo "${RED}âŒ ERROR: origin/master ref not found in shared submodule${NC}"
      echo "The shared repository may not be properly initialized."
      echo ""
      exit 1
    fi

    # Check for unpushed commits using git rev-list (more reliable than grep)
    unpushed_count=$(git rev-list origin/master..HEAD 2>/dev/null | wc -l | tr -d ' ')
    unpushed_shas=$(git log --format='%H' origin/master..HEAD 2>/dev/null)

    if [ "$unpushed_count" -gt 0 ]; then
      # Check if pointer commit is in the unpushed list
      pointer_unpushed=$(echo "$unpushed_shas" | grep -q "^$new_pointer" && echo "yes" || echo "no")

      # Get current HEAD SHA
      head_sha=$(git rev-parse HEAD 2>/dev/null)
      head_short=$(echo "$head_sha" | cut -c1-7)

      # Check if there are commits above the pointer
      commits_above=""
      if [ "$head_sha" != "$new_pointer" ]; then
        commits_above=$(git log --format='%h %s' "$new_pointer"..HEAD 2>/dev/null)
      fi

      echo ""
      echo "${RED}âŒ ERROR: Cannot push to 'web' branch${NC}"
      echo ""
      echo "The ${YELLOW}shared${NC} submodule pointer references commit ${YELLOW}$new_pointer_short${NC} which hasn't been pushed to GitHub yet."
      echo ""
      echo "Unpushed commits (${RED}$unpushed_count total${NC}):"

      # Show commits in default order (newest first) with pointer marked
      git log --format='%h %s' origin/master..HEAD 2>/dev/null | while read sha rest; do
        if [ "$sha" = "$new_pointer_short" ]; then
          echo "  ${YELLOW}* $sha${NC} $rest ${YELLOW}(required)${NC}"
        elif [ -n "$commits_above" ] && echo "$commits_above" | grep -q "^$sha "; then
          echo "    ${GRAY}$sha${NC} $rest ${BLUE}(optional)${NC}"
        else
          echo "    ${WHITE}$sha${NC} $rest"
        fi
      done

      echo ""
      echo "Your website deployment depends on commit ${YELLOW}$new_pointer_short${NC} existing on GitHub."
      if [ -n "$commits_above" ]; then
        echo "Commits marked ${BLUE}(optional)${NC} are newer than the pointer and not required for this push."
      fi
      echo "Push shared commits first, then push your website changes."
      echo ""
      echo "${GREEN}Fix:${NC} cd shared && git push origin master && cd .. && git push origin web"
      echo ""
      echo "Or bypass this check (not recommended): ${YELLOW}git push --no-verify origin web${NC}"
      echo ""
      exit 1
    fi

    # All good!
    echo "${GREEN}âœ“ Shared submodule is up to date${NC}"
    cd .. || exit 1
  fi
done

exit 0
